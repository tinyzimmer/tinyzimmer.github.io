<!DOCTYPE html>
<html lang="en-us"><head>
  
    
      






<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>GStreamer, Go, and Kubernetes | tinyzimmer&#39;s blog</title>
<meta name="title" content="GStreamer, Go, and Kubernetes | tinyzimmer&#39;s blog" />
<meta name="description" content="Back when I was working on kvdi (a Kubernetes-native &ldquo;Virtual Desktop Infrastructure&rdquo; written in Go), I got to the inevitable point that I wanted support for audio streams from the user desktops. In a web-based VDI solution, this posed several challenges:
 Raw PCM data is huge, and as such is not suitable for streaming over low latency networks.  To work with browser-native audio APIs, we need either raw PCM or one from a small set of browser supported encodings (WASM opens more doors, but I wanted to avoid it)."> 


<link rel="canonical" href="https://tinyzimmer.github.io/posts/gstreamer-go-and-k8s/" />


  
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:description" content="" /> 
  <meta name="twitter:title" content="GStreamer, Go, and Kubernetes | tinyzimmer&#39;s blog" />
  <meta name="twitter:url" content="https://tinyzimmer.github.io/posts/gstreamer-go-and-k8s/" />
  
  
  <meta name="twitter:image" content="/images/music-gopher.png" /> 



  
  <meta property="og:title" content="GStreamer, Go, and Kubernetes | tinyzimmer&#39;s blog" />
  <meta property="og:description" content="" /> 
  <meta property="og:site_name" content="tinyzimmer&#39;s blog" />
  <meta property="og:locale" content="en_US" />
  <meta property="og:type" content="article" />
  <meta property="og:url" content="https://tinyzimmer.github.io/posts/gstreamer-go-and-k8s/" />
  
  <meta property="og:image" content="/images/music-gopher.png" /> 



<meta property="article:published_time" content="2021-01-27 06:54:29 &#43;0200 IST" />


  
  
  <script type="application/ld+json">
      { 
          "@context": "http://schema.org", 
          "@type": "WebSite", 
          "url": "https://tinyzimmer.github.io/", 
          "name": "GStreamer, Go, and Kubernetes",
          "author": {
            "@type": "Person",
            "name": "Avi Zimmerman"
          },
          
          "image": "/images/music-gopher.png",
          "description": "A blog where I document my journeys through automation and code",
          
          "sameAs" : [
            
            
              "https://github.com/tinyzimmer"
            ]
          
        }
      </script>
  


    
    <meta name="generator" content="Hugo 0.81.0-DEV" />
  
  
  
  
  
  <link rel="stylesheet" href="/assets/css/main.min.aa781b4a2264b85cc06c9b412f6c205b64d0ef08c1885ae34e371912f036d991.css" integrity="sha256-qngbSiJkuFzAbJtBL2wgW2TQ7wjBiFrjTjcZEvA22ZE=" crossorigin="anonymous">
  
  <link rel="dns-prefetch" href="//fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin>
  
  <link rel=apple-touch-icon sizes=180x180 href=https://tinyzimmer.github.io//assets/favicon/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://tinyzimmer.github.io//assets/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://tinyzimmer.github.io//assets/favicon/favicon-16x16.png><link rel=manifest href=https://tinyzimmer.github.io//assets/favicon/site.webmanifest><link rel=mask-icon href=https://tinyzimmer.github.io//assets/favicon/safari-pinned-tab.svg color=#7817c4><link rel=icon href=https://tinyzimmer.github.io//assets/favicon/favicon.ico type=image/x-icon><link rel="shortcut icon" href=https://tinyzimmer.github.io//assets/favicon/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/main.css><meta name=apple-mobile-web-app-title content="Vibrant Shadows Theme"><meta name=application-name content="Vibrant Shadows Theme"><meta name=msapplication-TileColor content="#ffffff"><meta name=theme-color content="#ffffff">
  
  
  
  <meta name="theme-color" content="#fff6f8">
  
  <meta name="msapplication-navbutton-color" content="#fff6f8">
  
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  
  
</head>
<body><header>
  <nav class="navbar navbar-expand-lg navbar-light fixed-top flex-column">
    <div class="container-fluid">
      
      <a class="navbar-brand rounded px-3" href="https://tinyzimmer.github.io/"><span class="text-nav"><span class="brand">&nbsp;&nbsp;&nbsp;tinyzimmer&#39;s blog</span></span></a>
      
      
        <a class="navbar-toggler border-0 bg-nav p-2" role="button" href="#" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
          <span class="text-clr2">&#9776;</span>
        </a>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
          <ul class="navbar-nav mr-md-auto">
             
            
              
                <li class="nav-item mx-1 my-2">
                  <a class="btn bg-nav text-clr1" href="/about/">About</a>
                </li>
              
            
          </ul>
          
            
              <div class="navbar-navalign-items-center ml-md-auto my-2 bg-nav rounded p-1 pr-2">
                
                  
                    <a class="ml-1" href="https://github.com/tinyzimmer"><span class="fab fa-github" aria-label="Join us on Github"></span></a>
                  
                
              </div>
            
          
        </div>
      
    </div>
    
  </nav>
</header>
<div id="content">
<div class="container-fluid bg-clr1 text-nav text-center pb-3 pt-4 position-relative shadow-sm">
  <div style="height:3.5rem;"></div>
  <h1>GStreamer, Go, and Kubernetes</h1>
  
</div>
<div class="container bg-nav py-3">
  <hr>
<p>Back when I was working on <a href="https://github.com/tinyzimmer/kvdi">kvdi</a> (a Kubernetes-native &ldquo;Virtual Desktop Infrastructure&rdquo; written in Go), I got to the inevitable point that I wanted support for audio streams from the user desktops.
In a web-based VDI solution, this posed several challenges:</p>
<ul>
<li>Raw PCM data is huge, and as such is not suitable for streaming over low latency networks.
<ul>
<li>To work with browser-native audio APIs, we need either raw PCM or one from a small set of browser supported encodings (WASM opens more doors, but I wanted to avoid it).</li>
</ul>
</li>
<li>VNC, the protocol serving the user desktop displays, does not have support for audio.
<ul>
<li>QEMU Extended Audio exists in the protocol now, but is only implemented by the QEMU VNC server/client.</li>
</ul>
</li>
<li>While compensating for stream size and having to utilize side channels because of the above, we&rsquo;d still like to be able to achieve near real-time playback.
<ul>
<li>WebRTC can shine in areas like this, but facilitating the STUN protocol from inside a Kubernetes cluster was not an adventure I wanted to start just yet.</li>
</ul>
</li>
</ul>
<p>In another blog post I may go over these challenges and how I was able to overcome them in implementation, but that is not the purpose of this article.
For now, what&rsquo;s important is that PulseAudio, GStreamer, webm/opus, and websockets saved the day.
The first implementation was accomplished entirely through subprocesses and redirecting shell pipes, but this is a poor way to write code and an almost insulting way to utilize the true power of the GStreamer API ðŸ˜›.</p>
<p>Unfortunately, there didn&rsquo;t exist any truly comprehensive and feature-complete Go bindings for GStreamer, or at least any that implemented all of the APIs I needed to accomplish my goal. And so, <a href="https://github.com/tinyzimmer/go-gst">go-gst</a>, and later <a href="https://github.com/tinyzimmer/go-glib">go-glib</a> were forked and born.
I started from the excellent work done by the <a href="https://github.com/gotk3/gotk3">gotk3 project</a>, and then saw the rest of the GStreamer API bindings to pseudo-completion (these bindings remain actively developed with some help starting to come in from the community).</p>
<p>Fast forward a bit (and with huge thanks to <a href="https://coaxion.net/">slomo</a> from the GStreamer team and his fantastic write up on <a href="https://coaxion.net/blog/2017/09/exporting-a-gobject-c-api-from-rust-code-and-using-it-from-c-python-javascript-and-others/">exporting GObject APIs from Rust</a>), I found myself with the ability to write full GStreamer applications (and plugins!) entirely in Go.
I&rsquo;ll likely do another writeup in the future on the adventure of exporting GObjects from gocode, but for now the only question that remained was, what should I try next? Well since Go, where did that bring me? Right back to Kubernetes.</p>
<h2 id="gstreamer-pipelines-on-kubernetes">GStreamer Pipelines on Kubernetes</h2>
<p>The idea was simple. Define a <em>CustomResourceDefinition</em> that implements a sort of &ldquo;yamlized&rdquo; version of the better-known <code>gst-launch-1.0</code> from the GStreamer tools.
<em>CustomResources</em> using this API could have some arbitrary source destination watched for multimedia files, and have those objects automatically fed through their pipeline.
For source and destinations I chose MinIO first, primarily for the ease with which it can be deployed in development environments.</p>
<p>I started, as I do with almost all of my custom Kubernetes controllers, with the <a href="https://github.com/operator-framework/operator-sdk">operator-sdk</a>.
Perhaps I&rsquo;ll do a more in-depth post later on how the APIs and controllers were designed for this use case, but the meat of what I want to cover is in the translation from <code>yaml</code> to dynamic GStreamer pipelines.
In the end, the PoC for a <em>CustomResource</em> implementing one of the APIs looked like this:</p>
<p>The full PoC can be found here: <a href="https://github.com/tinyzimmer/gst-pipeline-operator">https://github.com/tinyzimmer/gst-pipeline-operator</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">    ---
    <span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">pipelines.gst.io/v1</span>
    <span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Transform</span>
    <span style="color:#f92672">metadata</span>:
      <span style="color:#f92672">name</span>: <span style="color:#ae81ff">mp4-converter</span>
    <span style="color:#f92672">spec</span>:
      <span style="color:#75715e"># Globals will be merged into the `src` and `sink` configs during processing.</span>
      <span style="color:#75715e"># This is useful if all operations are happening against the same MinIO server</span>
      <span style="color:#75715e"># and buckets. You can also direct output to/from different servers and buckets</span>
      <span style="color:#75715e"># by declaring those values in their respective areas instead of here.</span>
      <span style="color:#f92672">globals</span>:
        <span style="color:#f92672">minio</span>:
          <span style="color:#f92672">endpoint</span>: <span style="color:#e6db74">&#34;minio.default.svc.cluster.local:9000&#34;</span>   <span style="color:#75715e"># The endpoint for the MinIO server</span>
          <span style="color:#f92672">insecureNoTLS</span>: <span style="color:#66d9ef">true</span>                                <span style="color:#75715e"># Use HTTP</span>
          <span style="color:#f92672">region</span>: <span style="color:#ae81ff">us-east-1                                 </span> <span style="color:#75715e"># The region of the bucket</span>
          <span style="color:#f92672">bucket</span>: <span style="color:#ae81ff">gst-processing                            </span> <span style="color:#75715e"># The bucket to watch for files</span>
          <span style="color:#f92672">credentialsSecret</span>:                                 <span style="color:#75715e"># The secret containing READ credentials for MinIO</span>
            <span style="color:#f92672">name</span>: <span style="color:#ae81ff">minio-credentials</span>
      <span style="color:#f92672">src</span>:
        <span style="color:#f92672">minio</span>:
          <span style="color:#f92672">key</span>: <span style="color:#ae81ff">drop/  </span> <span style="color:#75715e"># Watch all files placed in the drop/ prefix</span>
      <span style="color:#f92672">sink</span>:
        <span style="color:#f92672">minio</span>:
          <span style="color:#f92672">key</span>: <span style="color:#e6db74">&#34;mp4/{{ .SrcName }}.mp4&#34;</span>   <span style="color:#75715e"># Generate an output name from this template. If the src file was called</span>
      <span style="color:#f92672">pipeline</span>:                           <span style="color:#75715e"># drop/video.mkv then this would evaluate to mp4/video.mp4.</span>
        <span style="color:#f92672">debug</span>:
          <span style="color:#f92672">dot</span>:
            <span style="color:#f92672">path</span>: <span style="color:#ae81ff">debug/ </span> <span style="color:#75715e"># Optionally dump DOT graphs to the debug/ prefix for each pipeline</span>
            <span style="color:#f92672">render</span>: <span style="color:#ae81ff">png  </span> <span style="color:#75715e"># Optionally render those DOT graphs to PNG in addition to the DOT format.</span>

        <span style="color:#75715e"># The pipeline definition. This is the &#34;yamlized&#34; version of the gst-launch-1.0 syntax.</span>
        <span style="color:#f92672">elements</span>:
        - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">decodebin</span>
          <span style="color:#f92672">alias</span>: <span style="color:#ae81ff">dbin         </span> <span style="color:#75715e"># The same as applying a `name` in gst-launch-1.0</span>

        - <span style="color:#f92672">goto</span>: <span style="color:#ae81ff">dbin          </span> <span style="color:#75715e"># Take a compatible sink pad from the decodebin</span>
        - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">queue</span>
        - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">audioconvert</span>
        - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">audioresample</span>
        - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">voaacenc</span>
        - <span style="color:#f92672">linkto</span>: <span style="color:#ae81ff">mux         </span> <span style="color:#75715e"># Link the output of this chain to the `mux` element</span>

        - <span style="color:#f92672">goto</span>: <span style="color:#ae81ff">dbin          </span> <span style="color:#75715e"># Go back to the decodebin and take the next compatible sink pad</span>
        - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">queue</span>
        - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">videoconvert</span>
        - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">x264enc</span>

        - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">mp4mux        </span> <span style="color:#75715e"># Joins the output from the audio stream and the video stream into an mp4</span>
          <span style="color:#f92672">alias</span>: <span style="color:#ae81ff">mux          </span> <span style="color:#75715e"># container.</span>
    
        <span style="color:#75715e"># The last element evaluated in the pipeline (either in order or via goto/linkto) has its output</span>
        <span style="color:#75715e"># sent to the MinIO output object.</span>
</code></pre></div><p>There is obviously a lot happening here besides just the pipeline parsing.
For example, the plugins facilitating the reading and writing to/from MinIO were written using the <code>go-gst</code> bindings as well, but we can table that discussion for another time.
The part I want to focus on is the <code>elements</code> block at the end.
This is where I ventured to mimic (as closely as possible) how this would look in <code>gst-launch-1.0</code> syntax. A comparable pipeline to the above on the command-line would look like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">    gst-launch-1.0 <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        miniosrc location<span style="color:#f92672">=</span>$object <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        ! decodebin name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;dbin&#34;</span> dbin. ! queue ! videoconvert ! x246enc <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        ! mp4mux name<span style="color:#f92672">=</span>mux ! miniosink location<span style="color:#f92672">=</span>$object.mp4 dbin. <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        ! queue ! audioconvert ! audioresample ! voaacenc ! mux.
</code></pre></div><p>The finished code that parses the <code>yaml</code> (after it has been deserialized) into a GStreamer pipeline can be found <a href="https://github.com/tinyzimmer/gst-pipeline-operator/blob/v0.0.1/cmd/runner/parse_cr_pipeline.go">here</a>, but we&rsquo;ll walk through it piece-by-piece.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span> 

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;errors&#34;</span>
	<span style="color:#e6db74">&#34;fmt&#34;</span>

	<span style="color:#e6db74">&#34;github.com/tinyzimmer/go-gst/gst&#34;</span>
	<span style="color:#a6e22e">pipelinesmeta</span> <span style="color:#e6db74">&#34;github.com/tinyzimmer/gst-pipeline-operator/apis/meta/v1&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">buildPipelineFromCR</span>(<span style="color:#a6e22e">cfg</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">pipelinesmeta</span>.<span style="color:#a6e22e">PipelineConfig</span>, <span style="color:#a6e22e">srcObject</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">pipelinesmeta</span>.<span style="color:#a6e22e">Object</span>, <span style="color:#a6e22e">sinkObjects</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">pipelinesmeta</span>.<span style="color:#a6e22e">Object</span>) (<span style="color:#f92672">*</span><span style="color:#a6e22e">gst</span>.<span style="color:#a6e22e">Pipeline</span>, <span style="color:#66d9ef">error</span>) {
	<span style="color:#a6e22e">pipeline</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gst</span>.<span style="color:#a6e22e">NewPipeline</span>(<span style="color:#e6db74">&#34;&#34;</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
	}

    <span style="color:#a6e22e">pipelineCfg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cfg</span>.<span style="color:#a6e22e">GetElements</span>()
    
	<span style="color:#a6e22e">src</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">makeSrcElement</span>(<span style="color:#a6e22e">srcObject</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
	}

    <span style="color:#a6e22e">pipeline</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#a6e22e">src</span>)

    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>}
</code></pre></div><p>The beginning is pretty straight-forward. First, we create a new <em>GstPipeline</em> with a generated name.
The <code>pipelineCfg</code> is populated with the deserialized contents of the <code>elements</code> block shown above in the <em>CustomResource</em>.
We then make our source MinIO element pointing at the object that triggered this pipeline and add it to the <em>GstPipeline</em>.</p>
<p>Now is where things begin to get exciting. We need to iterate the element configurations provided by the user, and link them up properly in the pipeline.
We also need to take into account that the user may have defined elements that are providing dynamic src pads and can&rsquo;t be linked right away, and we&rsquo;ll get more into that later.</p>
<p>To start, we&rsquo;ll declare some pointers outside of the scope of the <code>for</code> loop we are about to do.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// Track a pointer to the last element we iterated on in the pipeline
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">last</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">gst</span>.<span style="color:#a6e22e">Element</span> = <span style="color:#a6e22e">src</span>
<span style="color:#75715e">// Track a pointer to the user-supplied configuration defining that last element 
</span><span style="color:#75715e">// (with some extra metadata we added to help us later)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">lastCfg</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">pipelinesmeta</span>.<span style="color:#a6e22e">GstElementConfig</span>
</code></pre></div><p>We can now start looping through our elements:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">elementCfg</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">pipelineCfg</span> {

		<span style="color:#75715e">// If we are jumping in the pipeline - set the last pointers to the appropriate element and config
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">elementCfg</span>.<span style="color:#a6e22e">GoTo</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;&#34;</span> {
            <span style="color:#75715e">// Retrieve the user configuration for this element from the pipeline config
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// and set it to the last pointer.
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">lastCfg</span> = <span style="color:#a6e22e">pipelineCfg</span>.<span style="color:#a6e22e">GetByAlias</span>(<span style="color:#a6e22e">elementCfg</span>.<span style="color:#a6e22e">GoTo</span>)
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">lastCfg</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
				<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;No configuration referenced by alias %s&#34;</span>, <span style="color:#a6e22e">elementCfg</span>.<span style="color:#a6e22e">GoTo</span>)
			}
            <span style="color:#75715e">// Retrieve the actual gst.Element from the pipeline for this configuration and set it to the
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// last pointer. How this function works will be shown below.
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">last</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">elementForPipeline</span>(<span style="color:#a6e22e">pipeline</span>, <span style="color:#a6e22e">lastCfg</span>)
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
				<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
            }
            <span style="color:#75715e">// Continue on to the next element in the configuration
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">continue</span>
		}

		<span style="color:#75715e">// If we are linking the previous element - perform the links depending on the alias.
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// Sets the last pointers as well, but at this point the user is probably doing a goto
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// next or this is the end of the pipeline and will be linked directly to the MinIO sink.
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">elementCfg</span>.<span style="color:#a6e22e">LinkTo</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;&#34;</span> {
            <span style="color:#75715e">// Retrieve the configuration for the element we are linking to
</span><span style="color:#75715e"></span>            <span style="color:#a6e22e">thisCfg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">pipelineCfg</span>.<span style="color:#a6e22e">GetByAlias</span>(<span style="color:#a6e22e">elementCfg</span>.<span style="color:#a6e22e">LinkTo</span>)
            <span style="color:#75715e">// Retrieve the actual element we are linking to from the pipeline
</span><span style="color:#75715e"></span>            <span style="color:#a6e22e">thisElem</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">elementForPipeline</span>(<span style="color:#a6e22e">pipeline</span>, <span style="color:#a6e22e">thisCfg</span>)
            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
            }
            <span style="color:#75715e">// Perform the link, how this works will be shown below.
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">linkLast</span>(<span style="color:#a6e22e">pipeline</span>, <span style="color:#a6e22e">last</span>, <span style="color:#a6e22e">lastCfg</span>, <span style="color:#a6e22e">thisElem</span>, <span style="color:#a6e22e">thisCfg</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
				<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
			}
            <span style="color:#75715e">// Declare the linked-to element as the last element iterated on
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">last</span> = <span style="color:#a6e22e">thisElem</span>
            <span style="color:#a6e22e">lastCfg</span> = <span style="color:#a6e22e">thisCfg</span>
            <span style="color:#75715e">// Continue to the next element in the configuration
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">continue</span>
		}

        <span style="color:#75715e">// Neither of the conditions apply. This is just a regular element block with optional
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// properties.
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// Retrieve (or create) the element from the pipeline (more details below)
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">element</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">elementForPipeline</span>(<span style="color:#a6e22e">pipeline</span>, <span style="color:#a6e22e">elementCfg</span>)
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
		}
        <span style="color:#75715e">// Link to whatever the last pointers are set to
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">linkLast</span>(<span style="color:#a6e22e">pipeline</span>, <span style="color:#a6e22e">last</span>, <span style="color:#a6e22e">lastCfg</span>, <span style="color:#a6e22e">element</span>, <span style="color:#a6e22e">elementCfg</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
		}

        <span style="color:#75715e">// Set this element as the last object iterated on.
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">last</span> = <span style="color:#a6e22e">element</span>
		<span style="color:#a6e22e">lastCfg</span> = <span style="color:#a6e22e">elementCfg</span>
    }
    
    <span style="color:#75715e">// Finally we create the sink element and link it to wherever we ended in the loop.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">sink</span>, <span style="color:#a6e22e">sinkCfg</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">makeSinkElement</span>(<span style="color:#a6e22e">sinkobj</span>)
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
    }
    <span style="color:#a6e22e">pipeline</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#a6e22e">sink</span>)
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">linkLast</span>(<span style="color:#a6e22e">pipeline</span>, <span style="color:#a6e22e">last</span>, <span style="color:#a6e22e">lastCfg</span>, <span style="color:#a6e22e">sink</span>, <span style="color:#a6e22e">sinkCfg</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
    }
</code></pre></div><p>The two functions we need to explore a little more in-depth here to truly feel the magic, are <code>elementForPipeline</code> and <code>linkLast</code>.</p>
<p>The way it is utilized above, <code>elementForPipeline</code> needs to be an idempotent <em>GstElement</em> fetcher for us.
That is to say, if the element has not been created and added to the pipeline yet, we want to do so.
However, if it was already created and added to the pipeline, we don&rsquo;t want to recreate it and just want the original reference back.
How that looked in practice is like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">elementForPipeline</span>(<span style="color:#a6e22e">pipeline</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">gst</span>.<span style="color:#a6e22e">Pipeline</span>, <span style="color:#a6e22e">cfg</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">pipelinesmeta</span>.<span style="color:#a6e22e">GstElementConfig</span>) (<span style="color:#a6e22e">thiselem</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">gst</span>.<span style="color:#a6e22e">Element</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>) {
    <span style="color:#75715e">// Below this we set a name to the configuration that we can re-use later when we create
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// the element for the first time. This is the name that GStreamer generated and assigned
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// to the element when it was first created.
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// First check if we have that name set in our configuration.
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">name</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cfg</span>.<span style="color:#a6e22e">GetPipelineName</span>(); <span style="color:#a6e22e">name</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;&#34;</span> {
        <span style="color:#75715e">// We iterated on this configuration before, and thus already have the element&#39;s *real* name
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// We can retrieve the element reference directly from the pipeline by that name.
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">thiselem</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">pipeline</span>.<span style="color:#a6e22e">GetElementByName</span>(<span style="color:#a6e22e">name</span>)
        <span style="color:#66d9ef">return</span>
	}
    <span style="color:#75715e">// We did not set a name to this configuration, so we must be creating the element for the first time.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// makeElement is a bit of an ugly wrapper around taking the potential properties provided by the user
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// and converting them to GValues of the appropriate type based on the element&#39;s properties.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">thiselem</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">makeElement</span>(<span style="color:#a6e22e">cfg</span>)
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#66d9ef">return</span>
    }
    <span style="color:#75715e">// Add the element to the pipeline
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">pipeline</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#a6e22e">thiselem</span>)
    <span style="color:#75715e">// Set the name assigned to the element for later use.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">cfg</span>.<span style="color:#a6e22e">SetPipelineName</span>(<span style="color:#a6e22e">thiselem</span>.<span style="color:#a6e22e">GetName</span>())
	<span style="color:#66d9ef">return</span>
}
</code></pre></div><p>The other piece we want to explore is <code>linkLast</code>. Most elements in GStreamer provide static <code>src</code> and <code>sink</code> pads that can be linked
directly while the pipeline is being built. In the go bindings, this is as simple as calling <code>last.Link(this)</code>.
However, and in our example above as well, there are some elements that provide dynamic pads. In the example above this is the <code>decodebin</code> element.
I won&rsquo;t get into the full nitty-gritty of the magic happening underneath the hood in <code>decodebin</code>, but what&rsquo;s important for now is that when it is first created
it has no idea what sort of input it will be getting. After the stream has started it attempts to detect the formats it received, dynamically creates the necessary
decoding/demuxing elements, and then provides a src pad once it has linked its own elements internally.</p>
<p>It produces signals once it has set up pads it can provide, and the application can tap into those signals with callbacks to do dynamic linking at playtime.
With that in mind, let&rsquo;s look at the code.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">linkLast</span>(<span style="color:#a6e22e">pipeline</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">gst</span>.<span style="color:#a6e22e">Pipeline</span>, <span style="color:#a6e22e">last</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">gst</span>.<span style="color:#a6e22e">Element</span>, <span style="color:#a6e22e">lastCfg</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">pipelinesmeta</span>.<span style="color:#a6e22e">GstElementConfig</span>, <span style="color:#a6e22e">element</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">gst</span>.<span style="color:#a6e22e">Element</span>, <span style="color:#a6e22e">elementCfg</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">pipelinesmeta</span>.<span style="color:#a6e22e">GstElementConfig</span>) <span style="color:#66d9ef">error</span> {
    <span style="color:#75715e">// Check if the last element we are linking to has a static src pad we can link to the
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// sink pad on this element. If it does, we are in luck! Just perform the link and return.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// One thing to note is that the API does not yet support defining filter caps for linking.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// The bindings can do this via LinkFiltered, and for now in the K8s API the user can use
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// a capsfilter element.
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">srcpad</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">last</span>.<span style="color:#a6e22e">GetStaticPad</span>(<span style="color:#e6db74">&#34;src&#34;</span>); <span style="color:#a6e22e">srcpad</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">last</span>.<span style="color:#a6e22e">Link</span>(<span style="color:#a6e22e">element</span>)
	}

    <span style="color:#75715e">// Unfortunately we don&#39;t have static pads. In the example above, &#34;last&#34; currently represents
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// the decodebin element.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Similar to how we tracked names in the configurations we were passing around, another field
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// is present in the configuration structure that allows us to track peers for later consumption. 
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Add the element we are *supposed* to link as a peer to the configuration.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">lastCfg</span>.<span style="color:#a6e22e">AddPeer</span>(<span style="color:#a6e22e">elementCfg</span>)

    <span style="color:#75715e">// We are hoping (which is the case with decodebin at least) that the element will emit the &#34;no-more-pads&#34;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// signal once it has created all the src pads it can provide. We connect to this signal and add a callback
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// that will be executed after the pipeline has been started and decodebin has built out its own pipeline.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">last</span>.<span style="color:#a6e22e">Connect</span>(<span style="color:#e6db74">&#34;no-more-pads&#34;</span>, <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">self</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">gst</span>.<span style="color:#a6e22e">Element</span>) {
        <span style="color:#75715e">// Retrieve all the available pads from the element that emitted this signal
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">pads</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">self</span>.<span style="color:#a6e22e">GetPads</span>()
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			<span style="color:#a6e22e">self</span>.<span style="color:#a6e22e">ErrorMessage</span>(<span style="color:#a6e22e">gst</span>.<span style="color:#a6e22e">DomainLibrary</span>, <span style="color:#a6e22e">gst</span>.<span style="color:#a6e22e">LibraryErrorFailed</span>, <span style="color:#a6e22e">err</span>.<span style="color:#a6e22e">Error</span>(), <span style="color:#e6db74">&#34;&#34;</span>)
			<span style="color:#66d9ef">return</span>
        }
        <span style="color:#75715e">// We are now going to loop over the available pads and link them to the appropriate
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// elements that are already created and waiting for a friend in the pipeline.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">Pads</span>:
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">srcpad</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">pads</span> {
			<span style="color:#75715e">// Skip already linked and non-src pads
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">srcpad</span>.<span style="color:#a6e22e">IsLinked</span>() <span style="color:#f92672">||</span> <span style="color:#a6e22e">srcpad</span>.<span style="color:#a6e22e">Direction</span>() <span style="color:#f92672">!=</span> <span style="color:#a6e22e">gst</span>.<span style="color:#a6e22e">PadDirectionSource</span> {
				<span style="color:#66d9ef">continue</span> <span style="color:#a6e22e">Pads</span>
            }
            <span style="color:#75715e">// Iterate the peers that were registered to the configuration for this element
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">peer</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">lastCfg</span>.<span style="color:#a6e22e">GetPeers</span>() {
                <span style="color:#75715e">// Retrieve the actual element from the pipeline using the function we defined
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// earlier.
</span><span style="color:#75715e"></span>				<span style="color:#a6e22e">peerElem</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">elementForPipeline</span>(<span style="color:#a6e22e">pipeline</span>, <span style="color:#a6e22e">peer</span>)
				<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
					<span style="color:#a6e22e">self</span>.<span style="color:#a6e22e">ErrorMessage</span>(<span style="color:#a6e22e">gst</span>.<span style="color:#a6e22e">DomainLibrary</span>, <span style="color:#a6e22e">gst</span>.<span style="color:#a6e22e">LibraryErrorFailed</span>, <span style="color:#a6e22e">err</span>.<span style="color:#a6e22e">Error</span>(), <span style="color:#e6db74">&#34;&#34;</span>)
					<span style="color:#66d9ef">return</span>
                }
                <span style="color:#75715e">// Retrieve the sink pad from that element
</span><span style="color:#75715e"></span>				<span style="color:#a6e22e">peersink</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">peerElem</span>.<span style="color:#a6e22e">GetStaticPad</span>(<span style="color:#e6db74">&#34;sink&#34;</span>)
				<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">peersink</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
					<span style="color:#a6e22e">self</span>.<span style="color:#a6e22e">ErrorMessage</span>(<span style="color:#a6e22e">gst</span>.<span style="color:#a6e22e">DomainLibrary</span>, <span style="color:#a6e22e">gst</span>.<span style="color:#a6e22e">LibraryErrorFailed</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;peer %s does not have a static sink pad&#34;</span>, <span style="color:#a6e22e">peer</span>.<span style="color:#a6e22e">Name</span>), <span style="color:#e6db74">&#34;&#34;</span>)
					<span style="color:#66d9ef">return</span>
                }
                <span style="color:#75715e">// If this new src pad can be linked to the sink pad then link it.
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// We check CanLink first becuse there may be multiple src pads with
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// only specific elements compatible with the media type in them.
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">srcpad</span>.<span style="color:#a6e22e">CanLink</span>(<span style="color:#a6e22e">peersink</span>) {
					<span style="color:#a6e22e">srcpad</span>.<span style="color:#a6e22e">Link</span>(<span style="color:#a6e22e">peersink</span>)
					<span style="color:#66d9ef">continue</span> <span style="color:#a6e22e">Pads</span>
				}
			}
		}
	})

    <span style="color:#75715e">// We are done here - if we defined a callback it will get fired later.
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}
</code></pre></div><p>With the above all done (and Kubernetes APIs implemented), we go drop some random MKV into our &ldquo;drop/&rdquo; prefix in MinIO and see what gets created.
The additional fields on the <em>CustomResource</em> for debugging tell the runner (in areas not covered here) to also dump graphs of what the pipeline ends up looking like.</p>
<p>I recognize you may need to download and zoom to properly view the contents of the image.</p>
<div class="pipeline-img">
  <input type="checkbox" id="zoomCheck">
  <label for="zoomCheck">
    <img src="/images/gstreamer-pipeline-operator-dot.png">
  </label>
</div>
<p>We can see here that the MKV I dropped actually already contained H264 video. So we essentially converted it RAW, straight back into H264, and then just slapped it into a different container.
But the important thing is that all the linking (both static and dynamic) happened correctly!.</p>
<p>Well that&rsquo;s all I got for this post. If you found it interesting then stay tuned for my posts in the future, and feel free to hop over to my <a href="https://github.com/tinyzimmer">Github</a> and take a look at this and some of my other GStreamer related projects recently.</p>

</div>

    </div><footer class="text-center p-2 text-muted footer">
  
    
  

  

  <div class="py-2 copyright">
    <small>Copyright &#169; 2021 Avi Zimmerman</small>
  </div>
</footer>

    
    
    
    <script src="/assets/js/main.min.6ff0d57b7558f0225c80bade926a349330bc25d85e7ceff50d911f1156023c3e.js" integrity="sha256-b/DVe3VY8CJcgLrekmo0kzC8JdhefO/1DZEfEVYCPD4=" crossorigin="anonymous"></script>
    <script src="/assets/js/custom.min.c8274a0cac0477f854e63f09626cc63858bb2bc9db8faecbb2834846952c7fd6.js" integrity="sha256-yCdKDKwEd/hU5j8JYmzGOFi7K8nbj67LsoNIRpUsf9Y=" crossorigin="anonymous"></script>
    
    <link href="https://fonts.googleapis.com/css?family=Roboto|Lato&display=swap" rel="stylesheet">
    
    
    
  </body>
</html>
